\hypertarget{classThreadPoolExecutor}{}\section{Thread\+Pool\+Executor类 参考}
\label{classThreadPoolExecutor}\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}


线程池基本实现,任务被放在一个全局队列中,各个线程抢占式执行任务  




{\ttfamily \#include $<$threadpoolexecutor.\+hpp$>$}

\subsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classThreadPoolExecutor_a23c3df3798fd2141637fc57b7de601d0}{Thread\+Pool\+Executor} (int32\+\_\+t core\+Pool\+Size, int32\+\_\+t max\+Pool\+Size, const std\+::vector$<$ \hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$$>$ \&work\+Queue, const \hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler} \&handler, std\+::string prefix=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em \hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,work\+Queue的大小要不大于core\+Pool\+Size 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 \end{DoxyCompactList}\item 
\hyperlink{classThreadPoolExecutor_afe143198e44e4d896b0ada2307514d67}{Thread\+Pool\+Executor} (int32\+\_\+t core\+Pool\+Size, int32\+\_\+t max\+Pool\+Size, std\+::vector$<$ \hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$$>$ $\ast$work\+Queue, \hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler} $\ast$handler, std\+::string prefix=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em \hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,work\+Queue的大小要不大于core\+Pool\+Size 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 \end{DoxyCompactList}\item 
\hyperlink{classThreadPoolExecutor_a1d65f9842fd50425cf3ba82c4ffee246}{Thread\+Pool\+Executor} (int32\+\_\+t core\+Pool\+Size, int32\+\_\+t max\+Pool\+Size, std\+::string prefix=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em \hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,根据core\+Pool\+Size构造相同大小的work\+Queue 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a1d5a1c3330593f243959256d32068c15}\label{classThreadPoolExecutor_a1d5a1c3330593f243959256d32068c15}} 
virtual \hyperlink{classThreadPoolExecutor_a1d5a1c3330593f243959256d32068c15}{$\sim$\+Thread\+Pool\+Executor} ()
\begin{DoxyCompactList}\small\item\em $\sim$\+Thread\+Pool\+Executor 析构函数 \end{DoxyCompactList}\item 
bool \hyperlink{classThreadPoolExecutor_a334329e0226ed0e540bc3ebc52e8817e}{non\+Core\+Thread\+Alive} () const
\begin{DoxyCompactList}\small\item\em non\+Core\+Thread\+Alive 是否允许非核心线程超时,若允许则线程执行完 一个任务后不会退出,会继续存在 \end{DoxyCompactList}\item 
void \hyperlink{classThreadPoolExecutor_a0079d82c3ef52770771f5954debcdfd7}{non\+Core\+Thread\+Alive} (bool value)
\begin{DoxyCompactList}\small\item\em non\+Core\+Thread\+Alive 设置是否允许非核心thread超时并且在没有任务时终止 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a7d4bfa422c41a11fcdd33e7a1b2bcec8}\label{classThreadPoolExecutor_a7d4bfa422c41a11fcdd33e7a1b2bcec8}} 
virtual void \hyperlink{classThreadPoolExecutor_a7d4bfa422c41a11fcdd33e7a1b2bcec8}{release\+Workers} ()
\begin{DoxyCompactList}\small\item\em release\+Workers 释放所有线程(释放线程资源,并弹出线程队列) \end{DoxyCompactList}\item 
void \hyperlink{classThreadPoolExecutor_a5d2d340118dd847534533f8bf2e9ae94}{release\+Non\+Core\+Threads} (bool only\+One=false)
\begin{DoxyCompactList}\small\item\em release\+Non\+Core\+Threads 释放空闲线程(释放线程资源,并弹出线程队列) 只有在non\+Core\+Thread\+Alive为true时才有作用 \end{DoxyCompactList}\item 
virtual void \hyperlink{classThreadPoolExecutor_a0e8838b0dcb195c2b4693bdab1eacf39}{set\+Rejected\+Execution\+Handler} (\hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler} handler)
\begin{DoxyCompactList}\small\item\em set\+Rejected\+Execution\+Handler 设置新的任务拒绝策略 \end{DoxyCompactList}\item 
virtual bool \hyperlink{classThreadPoolExecutor_adb3c813875b9abfad2e6d67dabab2d53}{execute} (const \hyperlink{classRunnable}{Runnable} \&command, bool core=true)
\begin{DoxyCompactList}\small\item\em execute 在将来某个时候执行给定的任务,无返回值, 任务可以在新线程或现有的合并的线程中执行, 向任务队列提交的是任务副本 不会抛出异常 \end{DoxyCompactList}\item 
virtual bool \hyperlink{classThreadPoolExecutor_ae24770a14741a5d320da4cc78f01c2d6}{execute} (\hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$ \&commands, bool core=true)
\begin{DoxyCompactList}\small\item\em execute 在将来某个时候执行给定的任务,无返回值, 任务可以在新线程或现有的合并的线程中执行, 向任务队列提交的是任务副本 不会抛出异常 \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F $>$ }\\std\+::future$<$ typename std\+::result\+\_\+of$<$ F()$>$\+::type $>$ \hyperlink{classThreadPoolExecutor_a94834ab6bedcc75111524fec4e928b3f}{submit} (F f, bool core=true)
\begin{DoxyCompactList}\small\item\em submit 在将来某个时候执行给定的任务, 任务可以在新线程或现有的合并的线程中执行, 可以有返回值,向任务队列提交的是任务副本 会抛出异常 \end{DoxyCompactList}\item 
virtual std\+::string \hyperlink{classThreadPoolExecutor_a8e340cec3bb976f7773db103d73189c2}{to\+String} () const
\begin{DoxyCompactList}\small\item\em to\+String 返回标识此池的字符串及其状态，包括运行状态和估计的\+Worker和任务计数的指示 \end{DoxyCompactList}\item 
virtual int \hyperlink{classThreadPoolExecutor_aff3ba9327ffbc4d5660f7600f1199c76}{get\+Active\+Count} () const
\begin{DoxyCompactList}\small\item\em get\+Active\+Count 返回正在执行任务的线程的大概数量 \end{DoxyCompactList}\item 
virtual long \hyperlink{classThreadPoolExecutor_a61e8321202e6b0f6ea014485e8e10450}{get\+Task\+Count} () const
\begin{DoxyCompactList}\small\item\em get\+Task\+Count 得到任务队列大小 \end{DoxyCompactList}\item 
void \hyperlink{classThreadPoolExecutor_a83e9e3715fdacc5b2f08b563d39bb62b}{set\+Max\+Pool\+Size} (int max\+Pool\+Size)
\begin{DoxyCompactList}\small\item\em set\+Max\+Pool\+Size 设置允许的最大线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止 \end{DoxyCompactList}\item 
virtual int \hyperlink{classThreadPoolExecutor_a95b11de2c239d02800cc388f2f20bc4b}{get\+Ever\+Pool\+Size} () const
\begin{DoxyCompactList}\small\item\em get\+Largest\+Pool\+Size 返回池中使用过的线程数 \end{DoxyCompactList}\item 
int \hyperlink{classThreadPoolExecutor_a560e912bb988292e81d16274e3d4a5d8}{start\+Core\+Threads} ()
\begin{DoxyCompactList}\small\item\em start\+Core\+Threads 启动所有核心线程，导致他们等待工作。 这将覆盖仅在执行新任务时启动核心线程的默认策略 \end{DoxyCompactList}\item 
int \hyperlink{classThreadPoolExecutor_a9099318ba5cab5dd05f219babba4b6b7}{get\+Core\+Pool\+Size} () const
\begin{DoxyCompactList}\small\item\em get\+Core\+Pool\+Size 返回核心线程数 \end{DoxyCompactList}\item 
bool \hyperlink{classThreadPoolExecutor_aaada9deadf7c0f72bca5076deaa8c92f}{set\+Core\+Pool\+Size} (int32\+\_\+t core\+Pool\+Size)
\begin{DoxyCompactList}\small\item\em set\+Core\+Pool\+Size 设置核心线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止。 如果更大，则如果需要，新线程将被启动以执行任何排队的任务。 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a1963a058c29d90e1f7cdb755b83fdff0}\label{classThreadPoolExecutor_a1963a058c29d90e1f7cdb755b83fdff0}} 
virtual void \hyperlink{classThreadPoolExecutor_a1963a058c29d90e1f7cdb755b83fdff0}{shutdown} ()
\begin{DoxyCompactList}\small\item\em shutdown 不在接受新任务,并且在所有任务执行完后终止线程池 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_aaea5ac0ff50c7e198cb3f2a542a706c9}\label{classThreadPoolExecutor_aaea5ac0ff50c7e198cb3f2a542a706c9}} 
virtual void \hyperlink{classThreadPoolExecutor_aaea5ac0ff50c7e198cb3f2a542a706c9}{stop} ()
\begin{DoxyCompactList}\small\item\em stop 不在接受新任务,终止旧任务,释放正在运行的线程 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a6b09fafdffb979e7b422d67cb1958c20}\label{classThreadPoolExecutor_a6b09fafdffb979e7b422d67cb1958c20}} 
virtual void \hyperlink{classThreadPoolExecutor_a6b09fafdffb979e7b422d67cb1958c20}{try\+Terminate} ()
\begin{DoxyCompactList}\small\item\em try\+Terminate 尝试terminate线程池 \end{DoxyCompactList}\item 
virtual bool \hyperlink{classThreadPoolExecutor_a37702302c7a946b998ce92048ce68e2f}{is\+Shut\+Down} ()
\begin{DoxyCompactList}\small\item\em is\+Shut\+Down 判断线程池是否shutdown \end{DoxyCompactList}\item 
virtual bool \hyperlink{classThreadPoolExecutor_a7febfdf06752de6e4114f1de3ae9b135}{is\+Terminated} ()
\begin{DoxyCompactList}\small\item\em is\+Terminated 判断线程池是否terminated \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a61774315237123faf8e7fcc9d35ae47d}\label{classThreadPoolExecutor_a61774315237123faf8e7fcc9d35ae47d}} 
virtual void \hyperlink{classThreadPoolExecutor_a61774315237123faf8e7fcc9d35ae47d}{terminated} ()
\begin{DoxyCompactList}\small\item\em terminated 线程池终止时执行 \end{DoxyCompactList}\item 
bool \hyperlink{classThreadPoolExecutor_af961c5c8f699e77673627a19aad363f6}{add\+Worker} (const \hyperlink{classRunnable}{Runnable} first\+Task, bool core=true)
\begin{DoxyCompactList}\small\item\em add\+Worker 将任务添加到队列 \end{DoxyCompactList}\item 
virtual void \hyperlink{classThreadPoolExecutor_a554449ac43b629a1daced2000d730ecf}{advance\+Run\+State} (int32\+\_\+t target\+State)
\begin{DoxyCompactList}\small\item\em advance\+Run\+State 改变线程池状态 \end{DoxyCompactList}\item 
virtual void \hyperlink{classThreadPoolExecutor_a5e40839bf4191b5eab9d81227ddb62c3}{core\+Worker\+Thread} (size\+\_\+t queue\+Idex)
\begin{DoxyCompactList}\small\item\em core\+Worker\+Thread 线程池主循环 \end{DoxyCompactList}\item 
virtual void \hyperlink{classThreadPoolExecutor_a844902ce61fb16b11a569b8ee56e80e9}{worker\+Thread} (size\+\_\+t queue\+Idex)
\begin{DoxyCompactList}\small\item\em worker\+Thread 非核心线程循环 \end{DoxyCompactList}\item 
virtual void \hyperlink{classThreadPoolExecutor_a23a7c5908db3ef6f0e2afba6f0ca0450}{reject} (const \hyperlink{classRunnable}{Runnable} \&command)
\begin{DoxyCompactList}\small\item\em reject 将任务抛弃 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classThreadPoolExecutor_aa07228718089dc67885806cd663c1df1}\label{classThreadPoolExecutor_aa07228718089dc67885806cd663c1df1}} 
virtual bool {\bfseries compare\+And\+Increment\+Worker\+Count} (int expect)
\item 
\mbox{\Hypertarget{classThreadPoolExecutor_a3786ea6be7685ab4e6674014fbff35cd}\label{classThreadPoolExecutor_a3786ea6be7685ab4e6674014fbff35cd}} 
virtual bool {\bfseries compare\+And\+Decrement\+Worker\+Count} (int expect)
\item 
\mbox{\Hypertarget{classThreadPoolExecutor_ab19dcfa8af5864274e66bccf40255484}\label{classThreadPoolExecutor_ab19dcfa8af5864274e66bccf40255484}} 
virtual void \hyperlink{classThreadPoolExecutor_ab19dcfa8af5864274e66bccf40255484}{decrement\+Worker\+Count} ()
\begin{DoxyCompactList}\small\item\em decrement\+Worker\+Count 减少ctl的worker\+Count字段 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{静态 Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{classThreadPoolExecutor_aa7ca2a35d562746df0d77bd043bb75f0}{run\+State\+Of} (int32\+\_\+t c)
\begin{DoxyCompactList}\small\item\em run\+State\+Of 得到线程池状态 \end{DoxyCompactList}\item 
static int \hyperlink{classThreadPoolExecutor_af00080b50ff18ef719078b14b3df7291}{worker\+Count\+Of} (int32\+\_\+t c)
\begin{DoxyCompactList}\small\item\em worker\+Count\+Of 得到工作线程数量 \end{DoxyCompactList}\item 
static int32\+\_\+t \hyperlink{classThreadPoolExecutor_a73773038a4cce87d62e1c7715670aee7}{ctl\+Of} (int32\+\_\+t rs, int32\+\_\+t wc)
\begin{DoxyCompactList}\small\item\em ctl\+Of 控制变量初始化 \end{DoxyCompactList}\item 
static bool \hyperlink{classThreadPoolExecutor_a697d1afa93650fe597228fd5fb7b725b}{run\+State\+Less\+Than} (int c, int s)
\begin{DoxyCompactList}\small\item\em run\+State\+Less\+Than 状态低于 \end{DoxyCompactList}\item 
static bool \hyperlink{classThreadPoolExecutor_a5c20cff76deba933ace0f5a9f19ed5fd}{run\+State\+At\+Least} (int c, int s)
\begin{DoxyCompactList}\small\item\em run\+State\+At\+Least 运行状态最少是 \end{DoxyCompactList}\item 
static bool \hyperlink{classThreadPoolExecutor_a6a08024efe3dd52349a4c3cc3e816223}{is\+Running} (int c)
\begin{DoxyCompactList}\small\item\em is\+Running 是否还在运行 \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{详细描述}
线程池基本实现,任务被放在一个全局队列中,各个线程抢占式执行任务 

\subsection{构造及析构函数说明}
\mbox{\Hypertarget{classThreadPoolExecutor_a23c3df3798fd2141637fc57b7de601d0}\label{classThreadPoolExecutor_a23c3df3798fd2141637fc57b7de601d0}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{Thread\+Pool\+Executor()}{ThreadPoolExecutor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily Thread\+Pool\+Executor\+::\+Thread\+Pool\+Executor (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{core\+Pool\+Size,  }\item[{int32\+\_\+t}]{max\+Pool\+Size,  }\item[{const std\+::vector$<$ \hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$$>$ \&}]{work\+Queue,  }\item[{const \hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler} \&}]{handler,  }\item[{std\+::string}]{prefix = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,work\+Queue的大小要不大于core\+Pool\+Size 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 


\begin{DoxyParams}{参数}
{\em core\+Pool\+Size} & 核心线程数 \\
\hline
{\em max\+Pool\+Size} & 最大线程数 \\
\hline
{\em work\+Queue} & 任务队列 \\
\hline
{\em handler} & 拒绝任务句柄 \\
\hline
{\em prefix} & 线程名前缀 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_afe143198e44e4d896b0ada2307514d67}\label{classThreadPoolExecutor_afe143198e44e4d896b0ada2307514d67}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{Thread\+Pool\+Executor()}{ThreadPoolExecutor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily Thread\+Pool\+Executor\+::\+Thread\+Pool\+Executor (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{core\+Pool\+Size,  }\item[{int32\+\_\+t}]{max\+Pool\+Size,  }\item[{std\+::vector$<$ \hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$$>$ $\ast$}]{work\+Queue,  }\item[{\hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler} $\ast$}]{handler,  }\item[{std\+::string}]{prefix = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,work\+Queue的大小要不大于core\+Pool\+Size 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 


\begin{DoxyParams}{参数}
{\em core\+Pool\+Size} & 核心线程数 \\
\hline
{\em max\+Pool\+Size} & 最大线程数 \\
\hline
{\em work\+Queue} & 任务队列 \\
\hline
{\em handler} & 拒绝任务句柄 \\
\hline
{\em prefix} & 线程名前缀 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a1d65f9842fd50425cf3ba82c4ffee246}\label{classThreadPoolExecutor_a1d65f9842fd50425cf3ba82c4ffee246}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{Thread\+Pool\+Executor()}{ThreadPoolExecutor()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily Thread\+Pool\+Executor\+::\+Thread\+Pool\+Executor (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{core\+Pool\+Size,  }\item[{int32\+\_\+t}]{max\+Pool\+Size,  }\item[{std\+::string}]{prefix = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\hyperlink{classThreadPoolExecutor}{Thread\+Pool\+Executor} 构造函数,根据core\+Pool\+Size构造相同大小的work\+Queue 每个线程根据顺序将对应位置的\+Blocking\+Queue$<$\+Runnable$>$ 作为自己的任务队列 会抛出异常 


\begin{DoxyParams}{参数}
{\em core\+Pool\+Size} & 核心线程数 \\
\hline
{\em max\+Pool\+Size} & 最大线程数 \\
\hline
{\em prefix} & 线程名前缀 \\
\hline
\end{DoxyParams}


\subsection{成员函数说明}
\mbox{\Hypertarget{classThreadPoolExecutor_af961c5c8f699e77673627a19aad363f6}\label{classThreadPoolExecutor_af961c5c8f699e77673627a19aad363f6}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!add\+Worker@{add\+Worker}}
\index{add\+Worker@{add\+Worker}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{add\+Worker()}{addWorker()}}
{\footnotesize\ttfamily bool Thread\+Pool\+Executor\+::add\+Worker (\begin{DoxyParamCaption}\item[{const \hyperlink{classRunnable}{Runnable}}]{first\+Task,  }\item[{bool}]{core = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



add\+Worker 将任务添加到队列 


\begin{DoxyParams}{参数}
{\em first\+Task} & 任务 \\
\hline
{\em core} & 是否使用核心线程\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true -\/ 添加成功 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a554449ac43b629a1daced2000d730ecf}\label{classThreadPoolExecutor_a554449ac43b629a1daced2000d730ecf}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!advance\+Run\+State@{advance\+Run\+State}}
\index{advance\+Run\+State@{advance\+Run\+State}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{advance\+Run\+State()}{advanceRunState()}}
{\footnotesize\ttfamily virtual void Thread\+Pool\+Executor\+::advance\+Run\+State (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{target\+State }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



advance\+Run\+State 改变线程池状态 


\begin{DoxyParams}{参数}
{\em target\+State} & 目标状态 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a5e40839bf4191b5eab9d81227ddb62c3}\label{classThreadPoolExecutor_a5e40839bf4191b5eab9d81227ddb62c3}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!core\+Worker\+Thread@{core\+Worker\+Thread}}
\index{core\+Worker\+Thread@{core\+Worker\+Thread}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{core\+Worker\+Thread()}{coreWorkerThread()}}
{\footnotesize\ttfamily virtual void Thread\+Pool\+Executor\+::core\+Worker\+Thread (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{queue\+Idex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



core\+Worker\+Thread 线程池主循环 


\begin{DoxyParams}{参数}
{\em queue\+Idex} & 任务队列位置 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a73773038a4cce87d62e1c7715670aee7}\label{classThreadPoolExecutor_a73773038a4cce87d62e1c7715670aee7}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!ctl\+Of@{ctl\+Of}}
\index{ctl\+Of@{ctl\+Of}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{ctl\+Of()}{ctlOf()}}
{\footnotesize\ttfamily static int32\+\_\+t Thread\+Pool\+Executor\+::ctl\+Of (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{rs,  }\item[{int32\+\_\+t}]{wc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



ctl\+Of 控制变量初始化 


\begin{DoxyParams}{参数}
{\em rs} & 运行状态 \\
\hline
{\em wc} & 工作线程数量\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
控制变量的值 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_adb3c813875b9abfad2e6d67dabab2d53}\label{classThreadPoolExecutor_adb3c813875b9abfad2e6d67dabab2d53}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!execute@{execute}}
\index{execute@{execute}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{execute()}{execute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool Thread\+Pool\+Executor\+::execute (\begin{DoxyParamCaption}\item[{const \hyperlink{classRunnable}{Runnable} \&}]{command,  }\item[{bool}]{core = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



execute 在将来某个时候执行给定的任务,无返回值, 任务可以在新线程或现有的合并的线程中执行, 向任务队列提交的是任务副本 不会抛出异常 


\begin{DoxyParams}{参数}
{\em command} & 要执行的任务(Runnable或函数或lambda) \\
\hline
{\em core} & 是否使用核心线程\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true -\/ 添加成功 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_ae24770a14741a5d320da4cc78f01c2d6}\label{classThreadPoolExecutor_ae24770a14741a5d320da4cc78f01c2d6}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!execute@{execute}}
\index{execute@{execute}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{execute()}{execute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool Thread\+Pool\+Executor\+::execute (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockingQueue}{Blocking\+Queue}$<$ \hyperlink{classRunnable}{Runnable} $>$ \&}]{commands,  }\item[{bool}]{core = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



execute 在将来某个时候执行给定的任务,无返回值, 任务可以在新线程或现有的合并的线程中执行, 向任务队列提交的是任务副本 不会抛出异常 


\begin{DoxyParams}{参数}
{\em commands} & 要执行的任务队列 \\
\hline
{\em core} & 是否使用核心线程,如果为true,任务将被平均分配给核心线程 如果为flase,新建线程执行任务队列(前提是线程池小于max\+Pool\+Size)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true -\/ 任务全部放入执行队列 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_aff3ba9327ffbc4d5660f7600f1199c76}\label{classThreadPoolExecutor_aff3ba9327ffbc4d5660f7600f1199c76}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!get\+Active\+Count@{get\+Active\+Count}}
\index{get\+Active\+Count@{get\+Active\+Count}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{get\+Active\+Count()}{getActiveCount()}}
{\footnotesize\ttfamily virtual int Thread\+Pool\+Executor\+::get\+Active\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



get\+Active\+Count 返回正在执行任务的线程的大概数量 

\begin{DoxyReturn}{返回}
线程数 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a9099318ba5cab5dd05f219babba4b6b7}\label{classThreadPoolExecutor_a9099318ba5cab5dd05f219babba4b6b7}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!get\+Core\+Pool\+Size@{get\+Core\+Pool\+Size}}
\index{get\+Core\+Pool\+Size@{get\+Core\+Pool\+Size}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{get\+Core\+Pool\+Size()}{getCorePoolSize()}}
{\footnotesize\ttfamily int Thread\+Pool\+Executor\+::get\+Core\+Pool\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



get\+Core\+Pool\+Size 返回核心线程数 

\begin{DoxyReturn}{返回}
核心线程数 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a95b11de2c239d02800cc388f2f20bc4b}\label{classThreadPoolExecutor_a95b11de2c239d02800cc388f2f20bc4b}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!get\+Ever\+Pool\+Size@{get\+Ever\+Pool\+Size}}
\index{get\+Ever\+Pool\+Size@{get\+Ever\+Pool\+Size}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{get\+Ever\+Pool\+Size()}{getEverPoolSize()}}
{\footnotesize\ttfamily virtual int Thread\+Pool\+Executor\+::get\+Ever\+Pool\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



get\+Largest\+Pool\+Size 返回池中使用过的线程数 

\begin{DoxyReturn}{返回}
线程数 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a61e8321202e6b0f6ea014485e8e10450}\label{classThreadPoolExecutor_a61e8321202e6b0f6ea014485e8e10450}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!get\+Task\+Count@{get\+Task\+Count}}
\index{get\+Task\+Count@{get\+Task\+Count}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{get\+Task\+Count()}{getTaskCount()}}
{\footnotesize\ttfamily virtual long Thread\+Pool\+Executor\+::get\+Task\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



get\+Task\+Count 得到任务队列大小 

\begin{DoxyReturn}{返回}
任务队列大小 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a6a08024efe3dd52349a4c3cc3e816223}\label{classThreadPoolExecutor_a6a08024efe3dd52349a4c3cc3e816223}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!is\+Running@{is\+Running}}
\index{is\+Running@{is\+Running}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{is\+Running()}{isRunning()}}
{\footnotesize\ttfamily static bool Thread\+Pool\+Executor\+::is\+Running (\begin{DoxyParamCaption}\item[{int}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



is\+Running 是否还在运行 


\begin{DoxyParams}{参数}
{\em c} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}

\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a37702302c7a946b998ce92048ce68e2f}\label{classThreadPoolExecutor_a37702302c7a946b998ce92048ce68e2f}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!is\+Shut\+Down@{is\+Shut\+Down}}
\index{is\+Shut\+Down@{is\+Shut\+Down}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{is\+Shut\+Down()}{isShutDown()}}
{\footnotesize\ttfamily virtual bool Thread\+Pool\+Executor\+::is\+Shut\+Down (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



is\+Shut\+Down 判断线程池是否shutdown 

\begin{DoxyReturn}{返回}

\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a7febfdf06752de6e4114f1de3ae9b135}\label{classThreadPoolExecutor_a7febfdf06752de6e4114f1de3ae9b135}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!is\+Terminated@{is\+Terminated}}
\index{is\+Terminated@{is\+Terminated}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{is\+Terminated()}{isTerminated()}}
{\footnotesize\ttfamily virtual bool Thread\+Pool\+Executor\+::is\+Terminated (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



is\+Terminated 判断线程池是否terminated 

\begin{DoxyReturn}{返回}

\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a334329e0226ed0e540bc3ebc52e8817e}\label{classThreadPoolExecutor_a334329e0226ed0e540bc3ebc52e8817e}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!non\+Core\+Thread\+Alive@{non\+Core\+Thread\+Alive}}
\index{non\+Core\+Thread\+Alive@{non\+Core\+Thread\+Alive}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{non\+Core\+Thread\+Alive()}{nonCoreThreadAlive()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Thread\+Pool\+Executor\+::non\+Core\+Thread\+Alive (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



non\+Core\+Thread\+Alive 是否允许非核心线程超时,若允许则线程执行完 一个任务后不会退出,会继续存在 

\begin{DoxyReturn}{返回}
ture -\/ 允许非核心thread超时 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a0079d82c3ef52770771f5954debcdfd7}\label{classThreadPoolExecutor_a0079d82c3ef52770771f5954debcdfd7}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!non\+Core\+Thread\+Alive@{non\+Core\+Thread\+Alive}}
\index{non\+Core\+Thread\+Alive@{non\+Core\+Thread\+Alive}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{non\+Core\+Thread\+Alive()}{nonCoreThreadAlive()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Thread\+Pool\+Executor\+::non\+Core\+Thread\+Alive (\begin{DoxyParamCaption}\item[{bool}]{value }\end{DoxyParamCaption})}



non\+Core\+Thread\+Alive 设置是否允许非核心thread超时并且在没有任务时终止 


\begin{DoxyParams}{参数}
{\em value} & ture或false \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a23a7c5908db3ef6f0e2afba6f0ca0450}\label{classThreadPoolExecutor_a23a7c5908db3ef6f0e2afba6f0ca0450}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!reject@{reject}}
\index{reject@{reject}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{reject()}{reject()}}
{\footnotesize\ttfamily virtual void Thread\+Pool\+Executor\+::reject (\begin{DoxyParamCaption}\item[{const \hyperlink{classRunnable}{Runnable} \&}]{command }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



reject 将任务抛弃 


\begin{DoxyParams}{参数}
{\em command} & 要抛弃的任务 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a5d2d340118dd847534533f8bf2e9ae94}\label{classThreadPoolExecutor_a5d2d340118dd847534533f8bf2e9ae94}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!release\+Non\+Core\+Threads@{release\+Non\+Core\+Threads}}
\index{release\+Non\+Core\+Threads@{release\+Non\+Core\+Threads}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{release\+Non\+Core\+Threads()}{releaseNonCoreThreads()}}
{\footnotesize\ttfamily void Thread\+Pool\+Executor\+::release\+Non\+Core\+Threads (\begin{DoxyParamCaption}\item[{bool}]{only\+One = {\ttfamily false} }\end{DoxyParamCaption})}



release\+Non\+Core\+Threads 释放空闲线程(释放线程资源,并弹出线程队列) 只有在non\+Core\+Thread\+Alive为true时才有作用 


\begin{DoxyParams}{参数}
{\em only\+One} & 是否至终止一个空闲线程,默认终止所有线程 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a5c20cff76deba933ace0f5a9f19ed5fd}\label{classThreadPoolExecutor_a5c20cff76deba933ace0f5a9f19ed5fd}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!run\+State\+At\+Least@{run\+State\+At\+Least}}
\index{run\+State\+At\+Least@{run\+State\+At\+Least}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{run\+State\+At\+Least()}{runStateAtLeast()}}
{\footnotesize\ttfamily static bool Thread\+Pool\+Executor\+::run\+State\+At\+Least (\begin{DoxyParamCaption}\item[{int}]{c,  }\item[{int}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



run\+State\+At\+Least 运行状态最少是 


\begin{DoxyParams}{参数}
{\em c} & 控制变量 \\
\hline
{\em s} & 比较对象\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
bool c $<$ s 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a697d1afa93650fe597228fd5fb7b725b}\label{classThreadPoolExecutor_a697d1afa93650fe597228fd5fb7b725b}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!run\+State\+Less\+Than@{run\+State\+Less\+Than}}
\index{run\+State\+Less\+Than@{run\+State\+Less\+Than}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{run\+State\+Less\+Than()}{runStateLessThan()}}
{\footnotesize\ttfamily static bool Thread\+Pool\+Executor\+::run\+State\+Less\+Than (\begin{DoxyParamCaption}\item[{int}]{c,  }\item[{int}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



run\+State\+Less\+Than 状态低于 


\begin{DoxyParams}{参数}
{\em c} & 控制变量 \\
\hline
{\em s} & 比较对象\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
bool c $<$ s 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_aa7ca2a35d562746df0d77bd043bb75f0}\label{classThreadPoolExecutor_aa7ca2a35d562746df0d77bd043bb75f0}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!run\+State\+Of@{run\+State\+Of}}
\index{run\+State\+Of@{run\+State\+Of}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{run\+State\+Of()}{runStateOf()}}
{\footnotesize\ttfamily static int Thread\+Pool\+Executor\+::run\+State\+Of (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



run\+State\+Of 得到线程池状态 


\begin{DoxyParams}{参数}
{\em c} & 控制变量\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
运行状态 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_aaada9deadf7c0f72bca5076deaa8c92f}\label{classThreadPoolExecutor_aaada9deadf7c0f72bca5076deaa8c92f}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!set\+Core\+Pool\+Size@{set\+Core\+Pool\+Size}}
\index{set\+Core\+Pool\+Size@{set\+Core\+Pool\+Size}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{set\+Core\+Pool\+Size()}{setCorePoolSize()}}
{\footnotesize\ttfamily bool Thread\+Pool\+Executor\+::set\+Core\+Pool\+Size (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{core\+Pool\+Size }\end{DoxyParamCaption})}



set\+Core\+Pool\+Size 设置核心线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止。 如果更大，则如果需要，新线程将被启动以执行任何排队的任务。 

\begin{DoxyReturn}{返回}
void 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a83e9e3715fdacc5b2f08b563d39bb62b}\label{classThreadPoolExecutor_a83e9e3715fdacc5b2f08b563d39bb62b}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!set\+Max\+Pool\+Size@{set\+Max\+Pool\+Size}}
\index{set\+Max\+Pool\+Size@{set\+Max\+Pool\+Size}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{set\+Max\+Pool\+Size()}{setMaxPoolSize()}}
{\footnotesize\ttfamily void Thread\+Pool\+Executor\+::set\+Max\+Pool\+Size (\begin{DoxyParamCaption}\item[{int}]{max\+Pool\+Size }\end{DoxyParamCaption})}



set\+Max\+Pool\+Size 设置允许的最大线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止 


\begin{DoxyParams}{参数}
{\em max\+Pool\+Size} & 新的最大值 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a0e8838b0dcb195c2b4693bdab1eacf39}\label{classThreadPoolExecutor_a0e8838b0dcb195c2b4693bdab1eacf39}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!set\+Rejected\+Execution\+Handler@{set\+Rejected\+Execution\+Handler}}
\index{set\+Rejected\+Execution\+Handler@{set\+Rejected\+Execution\+Handler}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{set\+Rejected\+Execution\+Handler()}{setRejectedExecutionHandler()}}
{\footnotesize\ttfamily virtual void Thread\+Pool\+Executor\+::set\+Rejected\+Execution\+Handler (\begin{DoxyParamCaption}\item[{\hyperlink{classRejectedExecutionHandler}{Rejected\+Execution\+Handler}}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



set\+Rejected\+Execution\+Handler 设置新的任务拒绝策略 


\begin{DoxyParams}{参数}
{\em handler} & Rejected\+Execution\+Handler类对象 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classThreadPoolExecutor_a560e912bb988292e81d16274e3d4a5d8}\label{classThreadPoolExecutor_a560e912bb988292e81d16274e3d4a5d8}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!start\+Core\+Threads@{start\+Core\+Threads}}
\index{start\+Core\+Threads@{start\+Core\+Threads}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{start\+Core\+Threads()}{startCoreThreads()}}
{\footnotesize\ttfamily int Thread\+Pool\+Executor\+::start\+Core\+Threads (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



start\+Core\+Threads 启动所有核心线程，导致他们等待工作。 这将覆盖仅在执行新任务时启动核心线程的默认策略 

\begin{DoxyReturn}{返回}
线程数已启动 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a94834ab6bedcc75111524fec4e928b3f}\label{classThreadPoolExecutor_a94834ab6bedcc75111524fec4e928b3f}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!submit@{submit}}
\index{submit@{submit}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{submit()}{submit()}}
{\footnotesize\ttfamily template$<$typename F $>$ \\
std\+::future$<$typename std\+::result\+\_\+of$<$F()$>$\+::type$>$ Thread\+Pool\+Executor\+::submit (\begin{DoxyParamCaption}\item[{F}]{f,  }\item[{bool}]{core = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



submit 在将来某个时候执行给定的任务, 任务可以在新线程或现有的合并的线程中执行, 可以有返回值,向任务队列提交的是任务副本 会抛出异常 


\begin{DoxyParams}{参数}
{\em f} & 要提交的任务(Runnable或函数或lambda) \\
\hline
{\em core} & 是否使用核心线程(默认值true,不增加新线程)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
res 任务返回值的future 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a8e340cec3bb976f7773db103d73189c2}\label{classThreadPoolExecutor_a8e340cec3bb976f7773db103d73189c2}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!to\+String@{to\+String}}
\index{to\+String@{to\+String}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{to\+String()}{toString()}}
{\footnotesize\ttfamily virtual std\+::string Thread\+Pool\+Executor\+::to\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



to\+String 返回标识此池的字符串及其状态，包括运行状态和估计的\+Worker和任务计数的指示 

\begin{DoxyReturn}{返回}
一个标识这个池的字符串，以及它的状态 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_af00080b50ff18ef719078b14b3df7291}\label{classThreadPoolExecutor_af00080b50ff18ef719078b14b3df7291}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!worker\+Count\+Of@{worker\+Count\+Of}}
\index{worker\+Count\+Of@{worker\+Count\+Of}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{worker\+Count\+Of()}{workerCountOf()}}
{\footnotesize\ttfamily static int Thread\+Pool\+Executor\+::worker\+Count\+Of (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



worker\+Count\+Of 得到工作线程数量 


\begin{DoxyParams}{参数}
{\em c} & 控制变量\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
工作线程数量 
\end{DoxyReturn}
\mbox{\Hypertarget{classThreadPoolExecutor_a844902ce61fb16b11a569b8ee56e80e9}\label{classThreadPoolExecutor_a844902ce61fb16b11a569b8ee56e80e9}} 
\index{Thread\+Pool\+Executor@{Thread\+Pool\+Executor}!worker\+Thread@{worker\+Thread}}
\index{worker\+Thread@{worker\+Thread}!Thread\+Pool\+Executor@{Thread\+Pool\+Executor}}
\subsubsection{\texorpdfstring{worker\+Thread()}{workerThread()}}
{\footnotesize\ttfamily virtual void Thread\+Pool\+Executor\+::worker\+Thread (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{queue\+Idex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



worker\+Thread 非核心线程循环 


\begin{DoxyParams}{参数}
{\em queue\+Idex} & 任务队列位置 \\
\hline
\end{DoxyParams}


该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
threadpoolexecutor.\+hpp\end{DoxyCompactItemize}
